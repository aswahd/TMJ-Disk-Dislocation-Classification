from warnings import warn
from typing import List, Tuple, Union, Dict
from collections.abc import Sequence

from .base64ImageConverter import imgDecodeB64
import numpy as np
import cv2 as cv
from vtkmodules.vtkRenderingCore import (
    vtkRenderWindow,
    vtkRenderer,
    vtkRenderWindowInteractor,
)
from vtkmodules.vtkInteractionWidgets import (
    vtkOrientedGlyphContourRepresentation,
    vtkContourWidget,
)
from vtkmodules.vtkCommonDataModel import vtkPolyData, vtkCellArray
from vtkmodules.vtkCommonCore import vtkPoints
import re, os, json, sys, random

try:
    import skimage.transform

    USE_SKIMAGE = True
except ModuleNotFoundError:
    USE_SKIMAGE = False


class LabelData(object):
    """Label data holder, have the following attributes:
    self.header: dict
    self.images: List[np.ndarray]
    self.masks: List[Dict[str, ndarray]]
    self.contours: List[Dict[str, list]]
    self.classifications: List[Dict[str, str]]
    self.comments: List[str]
    self.path: str
    """

    def __init__(self, param_dict: dict) -> None:
        self.header: dict = {}
        self.images: List[np.ndarray] = []
        self.masks: List[Dict[str, np.ndarray]] = []
        self.contours: List[Dict[str, List[List[Tuple[int, int]]]]] = []
        self.classifications: List[Dict[str, str]] = []
        self.comments: List[str] = []
        self.uids: List[str] = []
        self.path: str
        for k, v in param_dict.items():
            setattr(self, k, v)

    def __str__(self):
        if not "Version" in self.header:  # compat <v1.6.0
            version_labeled = "<1.6.0"
        else:
            version_labeled = self.header["Version"]
        length_string = f"LabelData({len(self)})"
        reader_string = f"Reader: {self.header['Labeler']}"
        version_info = f"Application version: {version_labeled}"
        label_info = (
            f"Number of avaliable labels: {len(self.header['Config']['labels'])}"
        )
        to_show = [length_string, version_info, reader_string, label_info]
        return "\n".join(to_show)

    __repr__ = __str__

    def __len__(self):
        return len(self.images)

    def avalLabels(self):
        return self.header["Config"]["labels"]

    def colorMask(self, idx: int):
        assert idx < len(self) and idx >= 0, "invalid index."
        masks = self.masks[idx]
        image = self.images[idx]
        c_mask = np.zeros((*image.shape[:2], 3), np.uint8)
        config = self.header["Config"]
        for k, c in zip(config["labels"], config["label_colors"]):
            msk: np.ndarray = masks[k]  # 2D, 0 channel
            msk = np.concatenate(
                (msk[..., np.newaxis], msk[..., np.newaxis], msk[..., np.newaxis]),
                axis=-1,
            )
            c_mask = c_mask * (1 - msk) + msk * c
        return c_mask

    def grayMask(self, idx: int, num_dict: Dict[str, int]):
        assert idx < len(self) and idx >= 0, "invalid index."
        masks = self.masks[idx]
        image = self.images[idx]
        mask = np.zeros(image.shape[:2], int)
        for lbl in self.avalLabels():
            num: int = num_dict[lbl]
            msk = masks[lbl].astype(np.uint8)
            mask = (msk * num).astype(np.uint8) + mask * (1 - msk)
        return mask


class LabelSysReader(Sequence):
    """Read files generated by LabelSys app."""

    MAGNIFICATION = 1
    LINE_THICKNESS = 1

    def __init__(self, folder_list: List[str], label_config: dict = None) -> None:
        """
        - label_config: for compatbility use, can be set to None for new version ( > v1.1.0 )
        """
        self.fl = folder_list
        self.__label_config = label_config

    def __iter__(self):
        self._iter_counter = 0
        return self

    def __next__(self):
        if self._iter_counter < len(self.fl):
            self._iter_counter += 1
            return self.read(
                self._iter_counter - 1, self.MAGNIFICATION, self.LINE_THICKNESS
            )
        else:
            raise StopIteration

    def __getitem__(self, key) -> LabelData:
        if isinstance(key, int):
            return self.read(self.fl[key], self.MAGNIFICATION, self.LINE_THICKNESS)
        elif isinstance(key, slice):
            start = key.start
            stop = key.stop
            step = key.step
            return LabelSysReader(self.fl[start:stop:step])
        else:
            raise TypeError("Invalid argument type.")

    def __len__(self):
        return len(self.fl)

    def read(
        self, path: str, magnification: Union[float, int] = 1, line_thickness: int = 1
    ) -> LabelData:
        images = []
        masks = []
        contours = []
        classifications = []
        comments = []
        uids = []

        file_list = [x for x in os.listdir(path) if x.endswith(".json")]
        for file_name in sorted(
            file_list, key=lambda x: int(re.findall("\d+|$", x)[0])
        ):
            file_path = os.path.join(path, file_name)
            if file_name == "HEAD_0.json":
                with open(file_path, "r") as _f:
                    header = json.load(_f)
                    if not self.__label_config is None:
                        # for < v1.1.0:
                        header["Config"] = self.__label_config
            else:
                d = readDataSlice(file_path, magnification, line_thickness)
                images.append(d["img"])
                masks.append(d["msks"])
                contours.append(d["cnts"])
                comments.append(d["comment"])
                classifications.append(d["classification"])
                uids.append(d["uid"])
        return LabelData(
            {
                "header": header,
                "images": images,
                "masks": masks,
                "contours": contours,
                "comments": comments,
                "classifications": classifications,
                "uids": uids,
                "path": path,
            }
        )

    def toCOCO(self):
        raise NotImplementedError


def checkFolderEligibility(fpath: str) -> bool:
    assert os.path.isdir(fpath), "Input should be a directory (folder)"
    return "HEAD_0.json" in os.listdir(fpath)


def recursivelyFindLabelDir(root_dir: str) -> List[str]:
    """Recursively find directories generated by the software

    Args:
        root_dir (str): Top directory to start searching

    Returns:
        List[str]: list of valid directories
    """
    valid_labeldir = []
    for f_ in os.listdir(root_dir):
        sub_file = os.path.join(root_dir, f_)
        if os.path.isdir(sub_file):
            if f_.startswith("Label-") and checkFolderEligibility(sub_file):
                valid_labeldir.append(sub_file)
            else:
                valid_labeldir += recursivelyFindLabelDir(sub_file)
    return valid_labeldir


def readDataSlice(
    file_path: str, magnification: Union[int, float] = 1, line_thickness: int = 1
):
    """
    - line_thickness: the line thickness of the interpreted mask, if the label is open contour
    read one data slice (i.e. not header file), the image and masks are magified with masks obtained\
        with VTK finely interpreted.
    return image, masks: dict
    """
    if file_path.endswith(".json"):
        with open(file_path, "r") as _f:
            slice_data = json.load(_f)
    else:
        warn("Slice data should end with .json, but got {} instead.".format(file_path))
        return None

    # resize image
    if "Image" in slice_data:  # Older version compatbility (<1.5.4)
        img_ori = imgDecodeB64(slice_data["Image"], accelerate=True)
    else:
        img_ori = np.load(file_path[:-4] + "npz")["img"]
    if len(img_ori.shape) == 2:
        im_channel = 1
    elif len(img_ori.shape) == 3:
        im_channel = img_ori.shape[2]
    new_im_size = (
        (np.array(img_ori.shape[:2]) * magnification).astype(np.int_).tolist()
    )  # H, W
    if USE_SKIMAGE:
        if im_channel == 1:
            img = skimage.transform.resize(img_ori, new_im_size)
        else:
            img = skimage.transform.resize(img_ori, new_im_size + [im_channel])
    else:
        #  print("Opencv found, using opencv instead")
        img_ori_uint8 = (
            (img_ori - img_ori.min()) / (img_ori.max() - img_ori.min()) * 255
        )
        img_ori_uint8 = img_ori_uint8.astype(np.uint8)
        #  if im_channel == 1:
        #      img_ori_uint8 = np.concatenate((img_ori_uint8[:,:,np.newaxis], img_ori_uint8[:,:,np.newaxis], img_ori_uint8[:,:,np.newaxis]), axis = 2)
        img = cv.resize(
            img_ori_uint8, tuple(new_im_size[::-1]), interpolation=cv.INTER_LINEAR
        )

    masks = dict()
    cnts = dict()
    uid = None
    for label, data in slice_data["Data"].items():
        if not isinstance(data, list):
            # SOPInstanceUID, for version < 1.6.7
            uid = data
            continue
        if data == []:
            masks[label], cnts[label] = (np.zeros(img.shape[:2]), None)
        else:
            #############################################
            if label == "Condyle":
                for d in data:
                    d["Open"] = False
            #############################################
            masks[label], cnts[label] = _readOneLabel(
                img_ori.shape[:2], data, magnification, line_thickness
            )

    if "Classification" in slice_data:
        classification = slice_data["Classification"]
    else:
        # for version < 1.5.3
        classification = None
    class_dict = {}
    if not classification is None:
        for c in classification.split("&"):
            k, v = c.split(":")
            class_dict[k] = v
    if "Comment" in slice_data:
        comment = slice_data["Comment"]
    else:
        # for version < 1.5.0
        comment = ""
    if uid is None:
        uid = slice_data["Uid"]  # for version > 1.6.7
    return {
        "img": img,
        "msks": masks,
        "cnts": cnts,
        "comment": comment,
        "classification": class_dict,
        "uid": uid,
    }


def _readOneLabel(ori_im_size, data, magnification, line_thickness):
    """
    will be called by readDataSlice(...)
    - ori_im_size: original image size (H, W)
    - data: data from one label
    return one mask
    """
    new_im_size = (np.array(ori_im_size) * magnification).astype(np.int_)
    mask = np.zeros(new_im_size[:2], np.uint8)
    cnts = []
    for d in data:
        open_curve = d["Open"]
        pts = d["Points"]
        #  contour_widget.AddObserver('EndInteractionEvent', contourWidgetEndInteraction)
        #  contour_widget.AddObserver('WidgetValueChangedEvent', contourWidgetEndInteraction)

        pd = vtkPolyData()
        points = vtkPoints()
        lines = vtkCellArray()
        for i in range(len(pts)):
            points.InsertPoint(i, pts[i])

        if not open_curve:
            vertex_ids = list(range(len(pts))) + [0]
            lines.InsertNextCell(len(pts) + 1, vertex_ids)
        else:
            vertex_ids = list(range(len(pts)))
            lines.InsertNextCell(len(pts), vertex_ids)

        pd.SetPoints(points)
        pd.SetLines(lines)

        # create a contour widget
        renderer = vtkRenderer()
        ren_win = vtkRenderWindow()
        ren_win.AddRenderer(renderer)

        contourRep = vtkOrientedGlyphContourRepresentation()
        contour_widget = vtkContourWidget()

        iren = vtkRenderWindowInteractor()
        iren.SetRenderWindow(ren_win)
        contour_widget.SetInteractor(iren)
        contour_widget.SetRepresentation(contourRep)

        contour_widget.On()
        contour_widget.Initialize(pd, 1)

        cnt = _getFullCnt(contour_widget, ori_im_size)  # All points on the contour
        cnt = np.array(cnt) * magnification
        mask = drawMask(mask, cnt, open_curve, line_thickness)
        cnts.append(cnt)
    return mask, cnts


def _getFullCnt(contour_widget, img_shape):
    """
    Get all point position in a contour widget
    return point in (col, row)
    -img_shape : (H, W) - original image shape
    """
    if len(img_shape) == 3:
        img_shape = img_shape[:2]
    cnt = contour_widget
    rep = cnt.GetContourRepresentation()
    all_pts = []
    point = np.empty((3))
    for pt_id in range(rep.GetNumberOfNodes()):
        rep.GetNthNodeWorldPosition(pt_id, point)
        all_pts.append(_getBackCvCoord(*point[:2], img_shape))
        for ipt_id in range(rep.GetNumberOfIntermediatePoints(pt_id)):
            rep.GetIntermediatePointWorldPosition(pt_id, ipt_id, point)
            all_pts.append(_getBackCvCoord(*point[:2], img_shape))
    all_pts = np.array(all_pts)
    return all_pts.tolist()


def _getBackCvCoord(x_vtk, y_vtk, img_shape):
    """Get coordinate in (col, row)
    - img_shape: (W, H)"""
    return np.array([x_vtk + 1, img_shape[0] - 2 - y_vtk])


def drawMask(mask, cnt, open_curve, line_thickness):
    """
    draw the mask from contour points
    will be called by _readOneLabel()
    - mask: mask to be drawn
    - cnt: all points on the contour in (x, y)
    - open_curve: indicate if the contour is open
    - line_thickness: the line thickness if the contour is open
    """
    if not isinstance(cnt, np.ndarray):
        cnt = np.array(cnt)
    # cnt = _removeDuplicate2d(cnt.astype(int))
    cnt = np.rint(cnt).astype(int)
    cnt = _removeDuplicate2d(cnt)
    if open_curve:
        cnt = np.array(cnt)
        cv.polylines(mask, [cnt], False, 1, thickness=line_thickness)
    else:
        cnt = np.array([[arr] for arr in cnt])
        cv.fillPoly(mask, pts=[cnt], color=1)
    return mask


def gray2rgb(im):
    return np.concatenate(
        (im[:, :, np.newaxis], im[:, :, np.newaxis], im[:, :, np.newaxis]), axis=2
    )


def format2Uint8(im):
    return ((im - im.min()) / (im.max() - im.min()) * 255).astype(np.uint8)


def inspectOneSlice(slice_path):
    img, masks = readDataSlice(slice_path, magnification=1)
    img = format2Uint8(img)

    if len(img.shape) == 2:
        im_channel = 1
    elif len(img.shape) == 3:
        im_channel = img.shape[2]
    mask = np.zeros(img.shape[:2], np.float)
    value = 0
    for label, _mask in masks.items():
        value += 1
        mask = mask * (1 - _mask) + value * _mask
    mask = (mask / value) * 255
    mask = mask.astype(np.uint8)

    if im_channel == 1:
        show_im = np.concatenate((img, mask), axis=1)
    else:
        show_im = np.concatenate((img, gray2rgb(mask)), axis=1)
    cv.imshow(slice_path, cv.cvtColor(show_im, cv.COLOR_RGB2BGR))
    cv.waitKey(0)
    return masks


def _removeDuplicate2d(duplicate):
    final_list = []
    flag = True
    for num in duplicate:
        for num0 in final_list:
            if num[0] == num0[0] and num[1] == num0[1]:
                flag = False
        if flag:
            final_list.append(num)
        flag = True
    return final_list


def randomColorUINT8() -> Tuple[int, int, int]:
    choice = random.randint(0, 16777216)  # 256**3
    hex_str = hex(choice)[2:]
    return (int(hex_str[:2]), int(hex_str[2:4]), int(hex_str[4:]))


if __name__ == "__main__":
    slice_path = sys.argv[1]
    inspectOneSlice(slice_path)
